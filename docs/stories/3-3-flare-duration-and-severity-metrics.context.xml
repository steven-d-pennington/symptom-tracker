<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.3</storyId>
    <title>Flare Duration and Severity Metrics</title>
    <status>drafted</status>
    <generatedAt>2025-10-28</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/3-3-flare-duration-and-severity-metrics.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>As a user tracking flare patterns</asA>
    <iWant>I want to see statistical summaries of flare duration and severity</iWant>
    <soThat>So that I can understand typical outcomes and identify outliers</soThat>
    <tasks>
- [ ] Task 1: Extend analyticsRepository with metrics calculations (AC: #3.3.2, #3.3.3)
  - [ ] 1.1: Open `src/lib/repositories/analyticsRepository.ts` from Stories 3.1 and 3.2
  - [ ] 1.2: Define DurationMetrics interface in `src/types/analytics.ts`: { averageDuration: number | null, medianDuration: number | null, shortestDuration: number | null, longestDuration: number | null, resolvedFlareCount: number }
  - [ ] 1.3: Define SeverityMetrics interface in `src/types/analytics.ts`: { averagePeakSeverity: number | null, trendDistribution: { improving: number, stable: number, worsening: number, noData: number }, totalFlareCount: number }
  - [ ] 1.4: Implement getDurationMetrics(userId: string, timeRange: TimeRange): Promise&lt;DurationMetrics&gt;
  - [ ] 1.5: Query flares table: `db.flares.where({ userId, status: 'Resolved' }).toArray()`, filter by timeRange using withinTimeRange utility
  - [ ] 1.6: Calculate duration for each resolved flare: (endDate - startDate) in days
  - [ ] 1.7: Calculate averageDuration: sum of all durations / count, round to 1 decimal, null if no resolved flares
  - [ ] 1.8: Calculate medianDuration: sort durations, get middle value (or average of two middle values for even count), null if no resolved flares
  - [ ] 1.9: Calculate shortestDuration: Math.min(...durations), null if no resolved flares
  - [ ] 1.10: Calculate longestDuration: Math.max(...durations), null if no resolved flares
  - [ ] 1.11: Return DurationMetrics object with resolvedFlareCount
  - [ ] 1.12: Implement getSeverityMetrics(userId: string, timeRange: TimeRange): Promise&lt;SeverityMetrics&gt;
  - [ ] 1.13: Query all flares (active and resolved): `db.flares.where({ userId }).toArray()`, filter by timeRange
  - [ ] 1.14: For each flare, get peak severity from flareEvents table (max severity value, fallback to initial severity)
  - [ ] 1.15: Calculate averagePeakSeverity: sum of peak severities / count, round to 1 decimal, null if no flares
  - [ ] 1.16: For each flare, get most recent trend from flareEvents (eventType === 'status_update'), default 'N/A'
  - [ ] 1.17: Calculate trendDistribution: count flares by trend category, convert to percentages
  - [ ] 1.18: Return SeverityMetrics object with totalFlareCount
  - [ ] 1.19: Add TypeScript return type annotations and JSDoc comments

- [ ] Task 2: Create histogram and distribution calculation utilities (AC: #3.3.4)
  - [ ] 2.1: Create `src/lib/utils/histogramUtils.ts` file
  - [ ] 2.2: Define DurationBucket type: { label: string, minDays: number, maxDays: number | null, count: number }
  - [ ] 2.3: Implement calculateDurationHistogram(durations: number[]): DurationBucket[]
  - [ ] 2.4: Define buckets: [{ label: '0-7 days', min: 0, max: 7 }, { label: '8-14 days', min: 8, max: 14 }, { label: '15-30 days', min: 15, max: 30 }, { label: '31-60 days', min: 31, max: 60 }, { label: '60+ days', min: 60, max: null }]
  - [ ] 2.5: For each bucket, count durations falling within range
  - [ ] 2.6: Return array of DurationBucket objects with counts
  - [ ] 2.7: Define SeverityRange type: { label: string, range: string, color: string, count: number }
  - [ ] 2.8: Implement calculateSeverityDistribution(severities: number[]): SeverityRange[]
  - [ ] 2.9: Define ranges: [{ label: 'Mild', range: '1-3', color: 'green' }, { label: 'Moderate', range: '4-6', color: 'yellow' }, { label: 'Severe', range: '7-10', color: 'red' }]
  - [ ] 2.10: For each range, count severities within bounds
  - [ ] 2.11: Return array of SeverityRange objects with counts
  - [ ] 2.12: Export all types and functions

- [ ] Task 3: Extend useAnalytics hook for metrics data (AC: #3.3.5)
  - [ ] 3.1: Open `src/lib/hooks/useAnalytics.ts` from Story 3.1
  - [ ] 3.2: Add durationMetrics state: const [durationMetrics, setDurationMetrics] = useState&lt;DurationMetrics | null&gt;(null)
  - [ ] 3.3: Add severityMetrics state: const [severityMetrics, setSeverityMetrics] = useState&lt;SeverityMetrics | null&gt;(null)
  - [ ] 3.4: Update fetchData function to call analyticsRepository.getDurationMetrics and getSeverityMetrics in parallel with getProblemAreas
  - [ ] 3.5: Use Promise.all to fetch all three data sets concurrently
  - [ ] 3.6: Update states when data fetched: setDurationMetrics, setSeverityMetrics
  - [ ] 3.7: Return durationMetrics and severityMetrics in hook result object
  - [ ] 3.8: Maintain existing polling pattern (10 seconds) and window focus refetch
  - [ ] 3.9: Handle errors for new metrics gracefully (log but don't break UI)

- [ ] Task 4: Create MetricCard component (AC: #3.3.2, #3.3.3, #3.3.7)
  - [ ] 4.1: Create `src/components/analytics/MetricCard.tsx` component
  - [ ] 4.2: Accept props: label (string), value (number | string | null), unit (string, optional), icon (ReactNode), color (string, optional), ariaLabel (string)
  - [ ] 4.3: Display card with border, rounded, p-4, bg-white
  - [ ] 4.4: Render icon in top-left with specified color
  - [ ] 4.5: Render label as text-sm text-gray-600
  - [ ] 4.6: Render value as text-2xl font-bold with optional color class
  - [ ] 4.7: Append unit to value if provided (e.g., "12.5 days")
  - [ ] 4.8: Handle null values: display "No data" in gray
  - [ ] 4.9: Add aria-label prop for screen readers
  - [ ] 4.10: Add tabIndex={0} for keyboard navigation
  - [ ] 4.11: Style with Tailwind, responsive sizing
  - [ ] 4.12: Follow MetricCard pattern from Story 3.1 RegionStatisticsCard

- [ ] Task 5: Create DurationMetricsView component (AC: #3.3.2, #3.3.6)
  - [ ] 5.1: Create `src/components/analytics/DurationMetricsView.tsx` component
  - [ ] 5.2: Accept props: durationMetrics (DurationMetrics | null), isLoading (boolean)
  - [ ] 5.3: Handle loading state: show skeleton cards (4 placeholders)
  - [ ] 5.4: Handle insufficient data: if durationMetrics?.resolvedFlareCount &lt; 3, show MetricsEmptyState
  - [ ] 5.5: Display section header: "Duration Metrics"
  - [ ] 5.6: Render grid layout: 4 MetricCard components (2x2 on desktop, stack on mobile)
  - [ ] 5.7: Card 1: Average Duration with Clock icon, value durationMetrics.averageDuration, unit "days"
  - [ ] 5.8: Card 2: Median Duration with TrendingDown icon, value durationMetrics.medianDuration, unit "days"
  - [ ] 5.9: Card 3: Shortest Duration with minimalist icon, value durationMetrics.shortestDuration, unit "days"
  - [ ] 5.10: Card 4: Longest Duration with TrendingUp icon, value durationMetrics.longestDuration, unit "days"
  - [ ] 5.11: Add responsive container styling: grid grid-cols-1 md:grid-cols-2 gap-4
  - [ ] 5.12: Follow grid layout patterns from Story 3.2 RegionStatisticsCard

- [ ] Task 6: Create SeverityMetricsView component (AC: #3.3.3, #3.3.6)
  - [ ] 6.1: Create `src/components/analytics/SeverityMetricsView.tsx` component
  - [ ] 6.2: Accept props: severityMetrics (SeverityMetrics | null), isLoading (boolean)
  - [ ] 6.3: Handle loading state: show skeleton cards
  - [ ] 6.4: Handle insufficient data: if severityMetrics?.totalFlareCount &lt; 3, show MetricsEmptyState
  - [ ] 6.5: Display section header: "Severity Metrics"
  - [ ] 6.6: Render grid layout: 5 MetricCard components
  - [ ] 6.7: Card 1: Average Peak Severity with Activity icon, value severityMetrics.averagePeakSeverity, color coding (green/yellow/red)
  - [ ] 6.8: Card 2: Improving Trend % with ArrowDownRight icon, value trendDistribution.improving, unit "%", color green
  - [ ] 6.9: Card 3: Stable Trend % with ArrowRight icon, value trendDistribution.stable, unit "%", color gray
  - [ ] 6.10: Card 4: Worsening Trend % with ArrowUpRight icon, value trendDistribution.worsening, unit "%", color red
  - [ ] 6.11: Card 5: No Data % with HelpCircle icon, value trendDistribution.noData, unit "%", color gray
  - [ ] 6.12: Calculate severity color: getSeverityColor helper (1-3 green, 4-6 yellow, 7-10 red)
  - [ ] 6.13: Add responsive grid: grid grid-cols-1 md:grid-cols-3 lg:grid-cols-5 gap-4

- [ ] Task 7: Create DurationHistogramChart component (AC: #3.3.4)
  - [ ] 7.1: Create `src/components/analytics/DurationHistogramChart.tsx` component
  - [ ] 7.2: Accept props: durations (number[]), isLoading (boolean)
  - [ ] 7.3: Import Chart.js from existing dependency (solution-architecture.md)
  - [ ] 7.4: Use calculateDurationHistogram utility to get bucket data
  - [ ] 7.5: Configure Chart.js with type: 'bar', data: bucket counts, labels: bucket labels
  - [ ] 7.6: Set bar colors: gradient from light blue to dark blue
  - [ ] 7.7: Configure x-axis: categorical labels for buckets
  - [ ] 7.8: Configure y-axis: integer ticks, label "Number of Flares"
  - [ ] 7.9: Add chart title: "Flare Duration Distribution"
  - [ ] 7.10: Make responsive: maintainAspectRatio false, responsive true
  - [ ] 7.11: Add aria-label summarizing data: "Duration histogram showing X flares across Y buckets"
  - [ ] 7.12: Handle loading state: show skeleton chart placeholder
  - [ ] 7.13: Use canvas element for Chart.js rendering

- [ ] Task 8: Create SeverityDistributionChart component (AC: #3.3.4)
  - [ ] 8.1: Create `src/components/analytics/SeverityDistributionChart.tsx` component
  - [ ] 8.2: Accept props: severities (number[]), isLoading (boolean)
  - [ ] 8.3: Use calculateSeverityDistribution utility to get range data
  - [ ] 8.4: Configure Chart.js with type: 'bar', data: range counts, labels: range labels (Mild/Moderate/Severe)
  - [ ] 8.5: Set bar colors matching severity colors: green (#10b981), yellow (#eab308), red (#ef4444)
  - [ ] 8.6: Configure x-axis: categorical labels
  - [ ] 8.7: Configure y-axis: integer ticks, label "Number of Flares"
  - [ ] 8.8: Add chart title: "Severity Distribution"
  - [ ] 8.9: Make responsive with same config as histogram
  - [ ] 8.10: Add aria-label summarizing severity breakdown
  - [ ] 8.11: Handle loading state with skeleton

- [ ] Task 9: Create TrendPieChart component (AC: #3.3.4)
  - [ ] 9.1: Create `src/components/analytics/TrendPieChart.tsx` component
  - [ ] 9.2: Accept props: trendDistribution ({ improving, stable, worsening, noData }), isLoading (boolean)
  - [ ] 9.3: Configure Chart.js with type: 'pie', data: trend percentages, labels: ['Improving', 'Stable', 'Worsening', 'No Data']
  - [ ] 9.4: Set segment colors: green (#10b981), gray (#6b7280), red (#ef4444), light gray (#d1d5db)
  - [ ] 9.5: Configure legend: position 'right' on desktop, 'bottom' on mobile
  - [ ] 9.6: Add tooltips showing percentage and count
  - [ ] 9.7: Add chart title: "Flare Trend Outcomes"
  - [ ] 9.8: Make responsive with maintainAspectRatio false
  - [ ] 9.9: Add aria-label: "Pie chart showing X% improving, Y% stable, Z% worsening"
  - [ ] 9.10: Handle loading state with skeleton
  - [ ] 9.11: Handle empty data: show message "No trend data available"

- [ ] Task 10: Create MetricsEmptyState component (AC: #3.3.6)
  - [ ] 10.1: Create `src/components/analytics/MetricsEmptyState.tsx` component
  - [ ] 10.2: Accept props: flareCount (number), timeRange (TimeRange)
  - [ ] 10.3: Display heading: "Insufficient data to calculate metrics"
  - [ ] 10.4: Display explanation: "At least 3 flares are needed for meaningful statistical analysis."
  - [ ] 10.5: Display current count: "Currently {flareCount} flare(s) in this range."
  - [ ] 10.6: Suggest action: "Try selecting a different time range or continue tracking flares."
  - [ ] 10.7: Add BarChart3 icon from lucide-react
  - [ ] 10.8: Style with bg-gray-50, rounded, p-8, text-center
  - [ ] 10.9: Follow empty state patterns from Stories 3.1 and 3.2
  - [ ] 10.10: Add semantic HTML structure (section, heading hierarchy)

- [ ] Task 11: Create ProgressionMetricsSection component (AC: #3.3.1, #3.3.5)
  - [ ] 11.1: Create `src/components/analytics/ProgressionMetricsSection.tsx` component
  - [ ] 11.2: Accept props: durationMetrics (DurationMetrics | null), severityMetrics (SeverityMetrics | null), durations (number[]), severities (number[]), isLoading (boolean), timeRange (TimeRange)
  - [ ] 11.3: Render section header: "Progression Metrics"
  - [ ] 11.4: Check if sufficient data: totalFlareCount &gt;= 3
  - [ ] 11.5: If insufficient, render MetricsEmptyState with flareCount and timeRange
  - [ ] 11.6: If sufficient, render three subsections: Duration Metrics, Severity Metrics, Visualizations
  - [ ] 11.7: Render DurationMetricsView component passing durationMetrics and isLoading
  - [ ] 11.8: Render SeverityMetricsView component passing severityMetrics and isLoading
  - [ ] 11.9: Render Visualizations subsection with three charts: DurationHistogramChart, SeverityDistributionChart, TrendPieChart
  - [ ] 11.10: Use responsive grid for charts: grid grid-cols-1 lg:grid-cols-3 gap-6
  - [ ] 11.11: Add spacing between subsections: space-y-8
  - [ ] 11.12: Handle loading state with skeletons throughout

- [ ] Task 12: Update analytics page to include Progression Metrics (AC: #3.3.1)
  - [ ] 12.1: Open `src/app/(protected)/flares/analytics/page.tsx` from Story 3.1
  - [ ] 12.2: Import ProgressionMetricsSection component
  - [ ] 12.3: Access extended hook data: const { problemAreas, durationMetrics, severityMetrics, isLoading } = useAnalytics({ timeRange })
  - [ ] 12.4: Calculate durations array from resolved flares for histogram
  - [ ] 12.5: Calculate severities array from all flares for distribution
  - [ ] 12.6: Render ProgressionMetricsSection below ProblemAreasView
  - [ ] 12.7: Pass all required props to ProgressionMetricsSection
  - [ ] 12.8: Ensure timeRange state is shared between Problem Areas and Progression Metrics
  - [ ] 12.9: Add spacing: space-y-8 between sections
  - [ ] 12.10: Remove placeholder for future analytics (Story 3.3 now implemented)

- [ ] Task 13: Add comprehensive tests (AC: All)
  - [ ] 13.1: Update `src/lib/repositories/__tests__/analyticsRepository.test.ts`
  - [ ] 13.2: Test getDurationMetrics returns correct average, median, shortest, longest
  - [ ] 13.3: Test getDurationMetrics handles edge cases: no resolved flares, single flare, even/odd count for median
  - [ ] 13.4: Test getDurationMetrics filters by time range correctly
  - [ ] 13.5: Test getSeverityMetrics calculates average peak severity correctly
  - [ ] 13.6: Test getSeverityMetrics calculates trend distribution percentages accurately
  - [ ] 13.7: Test getSeverityMetrics handles edge cases: no flares, all same trend, missing trend data
  - [ ] 13.8: Create `src/lib/utils/__tests__/histogramUtils.test.ts`
  - [ ] 13.9: Test calculateDurationHistogram assigns flares to correct buckets
  - [ ] 13.10: Test calculateDurationHistogram handles boundary values (e.g., exactly 7 days, 14 days)
  - [ ] 13.11: Test calculateSeverityDistribution groups severities correctly (1-3, 4-6, 7-10)
  - [ ] 13.12: Create `src/components/analytics/__tests__/MetricCard.test.tsx`
  - [ ] 13.13: Test MetricCard renders label, value, unit, icon
  - [ ] 13.14: Test MetricCard handles null values with "No data"
  - [ ] 13.15: Test MetricCard applies color classes correctly
  - [ ] 13.16: Test MetricCard accessibility: aria-label, keyboard navigation
  - [ ] 13.17: Create `src/components/analytics/__tests__/ProgressionMetricsSection.test.tsx`
  - [ ] 13.18: Test ProgressionMetricsSection shows empty state when &lt; 3 flares
  - [ ] 13.19: Test ProgressionMetricsSection renders all subsections when data sufficient
  - [ ] 13.20: Test ProgressionMetricsSection shows loading skeletons during fetch
  - [ ] 13.21: Test charts render with correct data
  - [ ] 13.22: Test metrics update when time range changes
  - [ ] 13.23: Test accessibility: ARIA labels, keyboard navigation, screen reader compatibility
  - [ ] 13.24: Test color coding for severity metrics (green/yellow/red ranges)
    </tasks>
  </story>

  <acceptanceCriteria>
1. **AC3.3.1 — Analytics page displays Progression Metrics section:** Add "Progression Metrics" section to existing `/flares/analytics` page (from Story 3.1), section appears below Problem Areas section, section header includes title and uses same time range selector from Problem Areas (shared state), follows responsive layout patterns from Stories 3.1 and 3.2 (grid on desktop, stack on mobile). [Source: docs/epics.md#Story-3.3] [Source: docs/solution-architecture.md#Epic-3]

2. **AC3.3.2 — Duration metrics displayed with statistical summaries:** Display duration statistics calculated from analyticsRepository.getDurationMetrics(userId, timeRange): (1) average flare duration in days (mean of all resolved flares, rounded to 1 decimal), (2) median flare duration in days (50th percentile, rounded to 1 decimal), (3) shortest duration in days (minimum from resolved flares), (4) longest duration in days (maximum from resolved flares), metrics only calculated from resolved flares (status === 'Resolved'), active flares excluded from duration calculations, each metric displayed as card with label, value, and icon (Clock, TrendingDown, TrendingUp icons from lucide-react). [Source: docs/epics.md#Story-3.3] [Source: docs/PRD.md#FR012]

3. **AC3.3.3 — Severity metrics and trend distribution displayed:** Display severity statistics from analyticsRepository.getSeverityMetrics(userId, timeRange): (1) average peak severity (mean of all peak severity values from flares, rounded to 1 decimal, color-coded 1-3 green, 4-6 yellow, 7-10 red), (2) severity trend distribution showing percentage breakdown: % improving (trend === 'Improving'), % stable (trend === 'Stable'), % worsening (trend === 'Worsening'), % no data (trend === 'N/A'), percentages calculated from most recent trend value per flare, displayed as cards with color-coded values (improving green, stable gray, worsening red). [Source: docs/epics.md#Story-3.3]

4. **AC3.3.4 — Visual charts for metrics:** Display three chart visualizations: (1) Duration Histogram showing distribution of flare durations in day buckets (0-7 days, 8-14 days, 15-30 days, 31-60 days, 60+ days) using Chart.js bar chart with count per bucket, (2) Severity Distribution showing count of flares by severity level (1-3, 4-6, 7-10) using Chart.js bar chart with color coding, (3) Trend Pie Chart showing proportion of flares by trend outcome (Improving/Stable/Worsening/N/A) using Chart.js pie chart with segment colors matching trend colors from Story 3.2, all charts responsive with maintainAspectRatio configuration, charts use canvas for performance per solution-architecture.md. [Source: docs/epics.md#Story-3.3] [Source: docs/solution-architecture.md#Technology-Stack]

5. **AC3.3.5 — Metrics update with time range changes:** Progression Metrics section shares time range state with Problem Areas section (Story 3.1), changing time range in selector triggers recalculation of all metrics and charts for new time range, metrics use same useAnalytics hook pattern with 10-second polling from Story 3.1, loading skeleton shown during recalculation, smooth transitions when data updates. [Source: docs/epics.md#Story-3.3] [Source: docs/stories/story-3.1.md]

6. **AC3.3.6 — Empty state for insufficient data:** MetricsEmptyState component displays when fewer than 3 flares exist in selected time range, shows message "Insufficient data to calculate metrics" with explanation "At least 3 flares are needed for meaningful statistical analysis", suggests selecting different time range or logging more flares, follows empty state patterns from Stories 3.1 and 3.2 (semantic structure, helpful messaging), includes count of current flares in range ("Currently 1 flare in this range"). [Source: docs/epics.md#Story-3.3] [Source: docs/stories/story-3.1.md]

7. **AC3.3.7 — Metrics accessibility and screen reader support:** All metric cards include ARIA labels describing metric name and value, charts include aria-label with summary statistics, keyboard navigation through metric cards using Tab key, focus indicators clearly visible on interactive elements, metric values announced by screen readers with context (e.g., "Average duration: 12.5 days"), color coding supplemented with text labels for color-blind accessibility, follows WCAG 2.1 AA standards per NFR001. [Source: docs/epics.md#Story-3.3] [Source: docs/PRD.md#NFR001]
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/epics.md" title="Epic Breakdown" section="Story 3.3: Flare Duration and Severity Metrics">
Analytics page shows "Progression Metrics" section. Metrics displayed: average flare duration (days), median flare duration, shortest/longest duration, average peak severity, severity trend distribution (% improving vs worsening vs stable). Metrics update when time range changes and empty state appears if fewer than 3 flares.
      </doc>
      <doc path="docs/PRD.md" title="Product Requirements Document" section="Flare Analysis &amp; Reporting">
FR012: System shall calculate and display flare progression metrics: average duration, severity trends, and resolution patterns. NFR001: Body map interactions must respond within 100ms on mobile and desktop devices. NFR002: All flare data persists to local IndexedDB immediately with offline-first architecture.
      </doc>
      <doc path="docs/solution-architecture.md" title="Solution Architecture" section="Analytics (Epic 3)">
Analytics page load → useAnalytics hook → analyticsService.getProblemAreas() → analyticsRepository.aggregateByRegion() → Dexie query (indexed by bodyRegionId) → Return aggregated metrics → Chart.js visualization. MetricsDashboard.tsx uses `const { metrics } = useFlareMetrics({ timeRange }); // KPI cards + distribution charts`. Chart stack lists Chart.js (4.5.0) for analytics visualizations.
      </doc>
      <doc path="docs/stories/story-3.1.md" title="Story 3.1: Calculate and Display Problem Areas" section="Data &amp; State Considerations">
Time range filtering uses flare.startDate for comparisons and includes both active and resolved flares. Time range preference persists to localStorage with key `analytics-time-range-{userId}` and React Query staleTime of 10 seconds keeps analytics refreshed. Existing dependencies include `src/lib/utils/timeRange.ts`, `src/lib/hooks/useAnalytics.ts`, and ProblemAreas components for layout patterns.
      </doc>
      <doc path="docs/stories/story-3.2.md" title="Story 3.2: Per-Region Flare History" section="Repository Extensions">
Get peak severity from flare events by filtering severity values and using Math.max with fallback to flare.initialSeverity. Determine most recent trend by filtering events where eventType === 'status_update', sorting by timestamp descending, and defaulting to 'N/A'. Region history objects capture duration, peakSeverity, trendOutcome, and status for each flare.
      </doc>
      <doc path="docs/solution-architecture.md" title="Solution Architecture" section="Technology Stack">
Charts toolkit specifies Chart.js and chartjs-plugin-annotation as existing dependencies for analytics features. Analytics components roadmap lists MetricsDashboard, FlareTimeline, and Trend visualizations as part of Epic 3 deliverables. Performance target reiterates &lt;100ms interaction latency for analytics UI.
      </doc>
    </docs>

    <code>
      <artifact path="src/lib/repositories/analyticsRepository.ts" kind="repository" symbol="analyticsRepository" lines="1-160">
Extends analytics data access with getProblemAreas, getFlaresByRegion, and getRegionStatistics using Dexie queries and withinTimeRange helper. Provides patterns for duration/peak severity calculation and trend extraction to follow when adding getDurationMetrics and getSeverityMetrics.
      </artifact>
      <artifact path="src/lib/hooks/useAnalytics.ts" kind="hook" symbol="useAnalytics" lines="1-150">
Client hook polls analyticsRepository every 10 seconds, shares time range state, and exposes loading/error handling. Extend this hook to include durationMetrics and severityMetrics while preserving polling and focus refetch behavior.
      </artifact>
      <artifact path="src/types/analytics.ts" kind="types" symbol="TimeRange, FlareMetrics" lines="1-120">
Defines TimeRange union, ProblemArea, FlareMetrics placeholder, and region analytics interfaces. Add DurationMetrics and SeverityMetrics here so repository and hook share consistent typings.
      </artifact>
      <artifact path="src/lib/utils/timeRange.ts" kind="utility" symbol="withinTimeRange" lines="1-80">
Provides getTimeRangeMilliseconds, withinTimeRange predicate, and label helpers used across analytics. Reuse withinTimeRange for filtering resolved flares and ensure histogram utilities respect same definitions.
      </artifact>
      <artifact path="src/components/analytics/ProblemAreasView.tsx" kind="component" symbol="ProblemAreasView" lines="1-200">
Implements analytics section layout with shared time range selector, responsive grids, empty state, and loading skeletons. Follow this structure for ProgressionMetricsSection and reuse AnalyticsTimeRangeSelector for shared state.
      </artifact>
      <artifact path="src/app/(protected)/flares/analytics/page.tsx" kind="page" symbol="AnalyticsPage" lines="1-120">
Current analytics page renders ProblemAreasView and placeholder cards for future metrics. Story 3.3 replaces placeholder with ProgressionMetricsSection beneath existing problem areas.
      </artifact>
      <artifact path="src/lib/repositories/__tests__/analyticsRepository.test.ts" kind="test" symbol="analyticsRepository tests" lines="1-200">
Existing Jest suite seeds Dexie, covers getProblemAreas filtering, thresholds, and time range behavior. Extend to validate new duration and severity aggregations plus edge cases for empty datasets.
      </artifact>
    </code>

    <dependencies>
      <node>
        <package name="next" version="15.5.4">Next.js App Router framework</package>
        <package name="react" version="19.1.0">React library for UI components</package>
        <package name="dexie" version="4.2.0">IndexedDB wrapper for offline analytics queries</package>
        <package name="chart.js" version="4.5.0">Chart rendering for histograms, bars, and pie charts</package>
        <package name="react-chartjs-2" version="5.3.0">React bindings for Chart.js components</package>
        <package name="chartjs-plugin-annotation" version="3.1.0">Chart.js plugin already configured for analytics visuals</package>
        <package name="lucide-react" version="0.544.0">Icon set for metric cards and empty states</package>
        <package name="date-fns" version="4.1.0">Date helpers for duration calculations</package>
      </node>
      <devDependencies>
        <package name="jest" version="30.2.0">Testing framework for repositories and components</package>
        <package name="@testing-library/react" version="16.3.0">Render and interaction testing utilities</package>
        <package name="@testing-library/user-event" version="14.6.1">Keyboard and pointer simulation for accessibility tests</package>
        <package name="@testing-library/jest-dom" version="6.9.1">Extended Jest matchers for DOM assertions</package>
        <package name="fake-indexeddb" version="6.2.4">Mock IndexedDB implementation for Dexie in tests</package>
        <package name="typescript" version="5">TypeScript compiler for strict typings</package>
      </devDependencies>
    </dependencies>
  </artifacts>

  <constraints>
- **Repository Pattern**: Extend existing analyticsRepository rather than new services; reuse Dexie queries and withinTimeRange utility to stay aligned with on-demand calculations (ADR-004).
- **Offline-First Data**: All metrics derive from IndexedDB via Dexie with no network calls, honoring PRD NFR002 for offline persistence.
- **Time Range Synchronization**: Progression Metrics must share the same time range selector and localStorage key (`analytics-time-range-{userId}`) as ProblemAreasView for consistent filtering.
- **Performance Target**: Keep calculations under 100ms and use memoization where needed so Chart.js renders stay within NFR001 responsiveness.
- **Accessibility Standards**: Follow Story 3.1 and 3.2 patterns—ARIA labels on metric cards, keyboard focus indicators, color paired with textual labels, minimum 44px touch targets.
- **Chart.js Usage**: Leverage existing Chart.js configuration (maintainAspectRatio=false for responsive layouts) and Canvas rendering to meet solution-architecture guidance.
- **Empty State Threshold**: Enforce minimum of 3 flares before showing metrics; otherwise display MetricsEmptyState messaging consistent with previous analytics stories.
- **Polling Pattern**: Preserve 10-second polling and focus refetch implemented in useAnalytics so metrics update alongside problem areas without extra intervals.
  </constraints>

  <interfaces>
    <interface name="TimeRange" kind="TypeScript type" path="src/types/analytics.ts">
      <signature>
export type TimeRange = 'last30d' | 'last90d' | 'lastYear' | 'allTime';
      </signature>
    </interface>
    <interface name="FlareMetrics" kind="TypeScript interface" path="src/types/analytics.ts">
      <signature>
export interface FlareMetrics {
  averageDuration: number;
  averageSeverity: number;
  totalFlares: number;
  timeRange: TimeRange;
}
      </signature>
    </interface>
    <interface name="analyticsRepository.getFlaresByRegion" kind="Repository method" path="src/lib/repositories/analyticsRepository.ts">
      <signature>
export async function getFlaresByRegion(
  userId: string,
  regionId: string
): Promise&lt;RegionFlareHistory[]&gt;;
      </signature>
    </interface>
    <interface name="FlareEventRecord" kind="Database entity" path="src/lib/db/schema.ts">
      <signature>
export interface FlareEventRecord {
  id: string;
  flareId: string;
  eventType: "created" | "severity_update" | "trend_change" | "intervention" | "resolved";
  timestamp: number;
  severity?: number;
  trend?: "improving" | "stable" | "worsening";
  notes?: string;
}
      </signature>
    </interface>
  </interfaces>

  <tests>
    <standards>
Analytics code uses Jest with fake-indexeddb to validate Dexie queries and React Testing Library for components. Maintain 80% coverage, include accessibility assertions (role, aria-label, keyboard navigation), and reuse polling/persistence test helpers from existing analytics suites.
    </standards>
    <locations>
- src/lib/repositories/__tests__/analyticsRepository.test.ts
- src/lib/utils/__tests__/
- src/components/analytics/__tests__/
- src/app/(protected)/flares/analytics/__tests__/
    </locations>
    <ideas>
**AC3.3.2 — Duration metrics cards:**
- Repository tests for average/median/min/max durations including even-count medians and no resolved flares.
- Component tests verify MetricCard formats values, units, icons, and "No data" fallback.

**AC3.3.3 — Severity metrics distribution:**
- Repository tests ensure peak severity averaging and trend percentage calculations handle missing trend data.
- Component tests check color coding for trend cards and ARIA labels describing values.

**AC3.3.4 — Chart visualizations:**
- Utility tests confirm duration histogram and severity distribution bucket assignments at boundary values.
- Component tests assert Chart.js datasets receive expected labels/counts and aria-label summaries.

**AC3.3.5/AC3.3.6 — Shared state & empty state:**
- Hook tests confirm time range changes trigger concurrent fetches for problem areas and metrics.
- Section tests verify MetricsEmptyState renders when flare counts below threshold and hides when sufficient data.

**AC3.3.7 — Accessibility:**
- Keyboard navigation tests ensure metric cards focus in tab order and Enter key activates interactive elements.
- Screen reader snapshots validate aria-label strings announce metric name, value, and unit.
    </ideas>
  </tests>
</story-context>
